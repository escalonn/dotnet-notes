transactions can have savepoints
    SAVE TRANSACTION <savepoint-name>
    ROLLBACK TRANSACTION <savepoint-name>
views can be created with option SCHEMABINDING
    this means that the table(s) underneath the view cannot be changed in a way that would break the view.
indexes, clustered and nonclustered
    default on primary key and unique
    often good idea to add on foreign keys
    CREATE NONCLUSTERED INDEX IX_name ON Movie.Movie ( GenreID )
scan: SQL Server iterates through many values looking for the right ones
seek: SQL Server is able to look up what it needs much faster (binary search) using an index
    think about when the indexes can actually be used.
    if your query has a WHERE IndexedCol = val, we can use it.
    if it has WHERE SOME_FUNCTION(IndexedCal) = val, we can't use it.
azure query performance insights
sql profiler (not available for azure sql db)
in some cases, a join-based query can be faster than a subquery-based query, namely when the subquery is doing some EXISTS check based on the values from the outer query. we should replace that with INNER JOIN.

ADO.NET consistent interface with many providers
    for specific data access technologies e.g. sql server, odbc, etc
each provider implements IDbConnection, IDbCommand, IDataReader, IDataAdapter.
connection connects to the database
command sends commands/queries over a connection and returns data if applicable,
    as a data reader (command.ExecuteReader()), DataSet (via a data adapter), or single value
data reader iterates forward (reader.Read()) through database result set
    holds one row at a time - get current values with reader[columnName]
    used (directly) in connected architecture
        very memory-efficient
data adapter loads a db result set into memory, and can apply changes back to the db
    used in disconnected architecture
DataSet holds tabular data, usually from a db result set
    usually filled by a data adapter (adapter.Fill(dataSet))
    contains DataTables, which contain DataRows and DataColumns

object-relational mapper
    e.g. Hibernate, Django, Entity Framework
    EF versions: EF 6, EF Core

database-first
    reverse engineer edmx model from db (but not in EF core)
    reverse engineer entity classes directly from db
model-first
    edmx file, made with gui designer, manually or reverse-engineered from db
    can generate database scripts from the model
    can generate entity classes from the model
    not supported by ef core
code-first
    write entity classes, connect to database
    can create the database if it doesn't exist
    can generate and apply migrations to manage the db structure via code

Entity Framework also needs a database provider to implement
    its abstractions for a specific db technology e.g. sql server, sqlite, inmemory, etc

explicit loading - load related data explicitly after original query
    uses Entry and Load methods. manual lazy loading in bulk - no real reason to use it.
eager loading - load related data as part of original query
    preferred way. Include, ThenInclude. take advantage of sql joins.
lazy loading - load related data at the moment of accessing each navigation property
    do not use - subject to n+1 problem, not worth it.
    disabled by default - enabled with UseLazyLoadingProxies call
    and virtual keyword on properties. (virtual is otherwise unnecessary on entities)

entitystates: unchanged, added, modified, deleted, detached
    access/modify entity state directly with context.Entry(entity).EntityState
    these reflect ef's tracking behavior, and are read on savechanges to
    generate the commands to send to the db
