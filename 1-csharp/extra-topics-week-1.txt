https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/method-parameters
    click through to params, ref, and out.

testing
    unit test
        check smallest unit of functionality
        should be isolated from runtime dependencies
        advantages: easy to diagnose failures
        can be written earlier in development, and thus guard against regressions
            across more of the product's lifetime
        easiest to automate
    integration test
        check how two or more components work together, up to the whole system
        usually slower to run
        use integration tests for typical scenarios rather than every
            possible permutation - unit testing is a more efficient way to cover
            unusual edge cases.
        we can write integration tests using all the same libraries as unit
            testing, e.g. xUnit
    acceptance test
        verify that aspects of the whole system's functionality meet
        functional or technical requirements
        might be manual or automated

TDD test-driven development
    write (failing) tests before code.
    only write enough code to pass the test.
    then refactor & cleanup the code.
    work in small steps.

logging
    how do you diagnose errors or bugs in an app deployed to production?
    you can't use the debugger
    you really don't want to have to rebuild and redeploy the code just to begin
        to investigate a problem
    you should have written logging code beforehand.
    we use third-party logging libraries like Serilog and NLog because many apps
        benefit from similar abstractions. for example, we can change logging
        targets/providers without modifying any actual app code.
    log levels in .NET:
        Critical - app-wide failures, like invalid db connection
        Error - unhandled exception, that doesn't break the whole app
        Warning - unexpected conditions, handled exceptions.
        Information - important points in the flow of the app, so we can see it's ok
        Debug - track large amounts of data
        Trace - track very large amounts of data, when debugging specific things
    log Critical and Error in production,
        and maybe Warning and Info, but not Debug or Trace (too noisy,
        potential performance penalty)
    in Development, log everything but Trace depending on needs in the moment
    we can log whole exceptions as well as strings - good,
        so we can see their stack traces
