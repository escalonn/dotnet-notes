making more explicit some points for the separation of concerns in project 0...
1. the console app project must not directly access the dbcontext at all, except maybe for creating it. that is the job of repository class(es) in another project.
2. the console app project must not use any of the entity classes generated by entity framework. that is the job of repository class(es) in another project.
3. the ef-generated classes should not be modified to add business logic. that is the job of the business logic library project.
4. somewhere you will need to convert between data access objects and business logic objects, and it should not be in the console app.
5. there should not be any use of Console except in the console app project.

https://martinfowler.com/bliki/PresentationDomainDataLayering.html

-----

the job of the repository is just to keep all the entity-framework-related code in one place (so if things related to EF changed, you'd only have to fix issues in one place). the alternative would be to just use the dbcontext in helper methods in the console app, or even using it all over your main method or something. it would work, it would just be messier.

the job of the mapper in restaurantreviews is, to handle converting between the objects EF uses, and the objects the console app uses. the alternative would be, just putting that code in the repository, or even all over the app in different places.

the workflow in restaurant reviews for, e.g. a new thing to create is:
1. get user input
2. put it into a business logic object
3. pass that object to the repository's add method
4. inside that add method, we convert the business logic object to a data access object
5. that data access object is added to a DbSet and we call SaveChanges.
it's not essential to have two different sets of objects like that but it allows flexibility in how you represent things in the business logic side. you can use Dictionaries and things that EF can't handle.

-----

if you are behind with p0 trying to decide where to focus energies in what priority... rather than doing the whole UI part or the whole EF part at once, i recommend working feature by feature, starting with the more basic prerequisites. something like this.
1. user can log in by name (reading from customer DbSet/table)
2. user can register a new customer (writing to customer DbSet/table)
3. user can see (e.g.) a list of products available at a given store (reading from several DbSets/tables)
4. user can place an order (reading and writing several DbSets/tables).

remember you can make incremental updates to your data model: in db-first with SQL and then re-scaffolding; in code-first with adding a migration and updating the db.

with EF, don't forget about how you need the methods Include and ThenInclude to load data from multiple table at once into the navigation properties, otherwise they will appear null (unless this context has already loaded them in some earlier query)

as for how to get initial data into your DB... you can actually apply it using migrations alongside the table structure using HasData method, check the docs on it. but the simplest way for both db first and code first would just be to maintain a .sql file with a bunch of INSERT INTO to provide the initial data. even if you're doing code-first, of course you can still connect with SSMS and run commands.

-----

the expectations for project 0 presentation. they'll start at 9:30 tomorrow and have 5 minutes each, then they can expect questions from QC and from trainer. questions may be about the project's overall design, about how they may have used or not used features of C# or SQL in it. questions might also just be on week 2 content in general.
they should begin with an introduction giving their name, that then covers both the business purpose of the app, and the technologies used.
then they should demo the application, walking through its features and explaining them as they go. there may not be time to show everything, but they can show us most and tell us about the rest. looking at the p0 functionality requirements, anything they do not show or mention verbally will be assumed to be incomplete. we don't have time to ask about every feature they forgot to say.
they should prepare a demo workflow which effectively and rapidly shows as much functionality as they can.
then, a good concluding sentence or two, so it doesn't just trail off, and ask for questions.
it's essential to practice and plan. it is very obvious when someone has not practiced.
they should speak with volume, energy, and confidence, using the webcam to start out, but then moving to screen-sharing for the demo.
they don't have to show any code in the presentation, but if they have time for it, there's nothing wrong with it.
when it's their turn, they should be ready to go... not "oh i forgot to start visual studio, oh where is my solution, etc. etc."
